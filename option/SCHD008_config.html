<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>エスカレーター機能設定アプリ</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #ffffff; position: relative; overflow: auto; }
    .background-shapes { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none; }
    .background-shapes .shape { position: absolute; background-color: rgba(141, 206, 19, 0.329); border-radius: 50%; }
    .background-shapes .shape.square { border-radius: 0; }
    .shape1 { width: 200px; height: 200px; top: -100px; left: -100px; }
    .shape2 { width: 500px; height: 500px; bottom: 50px; left: -150px; }
    .container { max-width: 600px; margin: 0 auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); position: relative; z-index: 1; }
    h1 { text-align: center; color: #333; }
    .section { margin-bottom: 20px; }
    .section h2 { font-size: 1.2em; margin-bottom: 10px; color: #555; }
    .section .options { display: flex; flex-wrap: wrap; }
    .section label { margin-right: 20px; color: #333; display: flex; align-items: center; }
    .section input[type="checkbox"], .section input[type="radio"] {
      margin-right: 5px; appearance: none; width: 20px; height: 20px; border: 2px solid #333; border-radius: 50%; position: relative; cursor: pointer;
    }
    .section input[type="checkbox"]:checked::before, .section input[type="radio"]:checked::before {
      content: ''; position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; background-color: #333; border-radius: 50%; transform: translate(-50%, -50%);
    }
    .section input[type="checkbox"] { border-radius: 4px; }
    .section input[type="checkbox"]:checked::before { border-radius: 4px; }
    .button-container { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
    .button-container a, .button-container button {
      padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; text-decoration: none;
    }
    /* Explicit classes for start button to ensure coloring even when disabled */
    .start-enabled { background-color: #4CAF50 !important; color: white; }
    .start-disabled { background-color: #9E9E9E !important; color: white; }
    .debug-hidden { display: none; }
    .debug-visible { display: block; }
    /* Blink effect to show updates */
    .blink { animation: blinkAnim 300ms ease; }
    @keyframes blinkAnim { 0% { box-shadow: 0 0 0 rgba(0,0,0,0); } 50% { box-shadow: 0 0 10px rgba(76,175,80,0.6); } 100% { box-shadow: 0 0 0 rgba(0,0,0,0); } }
    .subtle { color:#666; font-size: 0.9em; text-align:center; margin-top:-8px; margin-bottom:12px; }
  </style>
</head>
<body>
  <div class="background-shapes">
    <div class="shape shape1"></div>
    <div class="shape shape2"></div>
  </div>
  <div class="container">
    <h1 id="title">エス1 機能設定</h1>
    <p class="subtle" id="whichHint">現在: エス1 を編集中（ボタンで切替できます）</p>
    <!-- Debug panel (hidden by default) -->
    <div id="debugPanel" class="debug-hidden" style="text-align:center; font-size:0.9em; color:#666; margin-top:6px;">
      <p id="wsStatus">WebSocket: connecting...</p>
      <p id="nearStatus">近接: es1=false es2=false</p>
      <p id="currentStatus">現在のページ: es1</p>
      <p id="recvCount" style="font-size:0.8em;">メッセージ受信: 0</p>
      <p id="lastRaw" style="font-size:0.8em;">最後のメッセージ: -</p>
    </div>
    <div class="button-container">
      <button id="toggleBtn" type="button">エス2 機能設定へ</button>
      <a href="http://192.168.4.1/">エス状態表示</a>
    </div>

    <!-- 起動停止設定 -->
    <div class="section">
      <h2>起動停止設定</h2>
      <div class="options">
        <label><input type="radio" name="direction" value="UP"> UP起動</label>
        <label><input type="radio" name="direction" value="DN"> DN起動</label>
        <label><input type="radio" name="direction" value="stop"> 停止</label>
      </div>
    </div>

    <!-- 運転設定 -->
    <div class="section">
      <h2>運転設定</h2>
      <div class="options">
        <label><input type="radio" name="operation" value="auto"> 自動</label>
        <label><input type="radio" name="operation" value="manual"> 手動</label>
      </div>
    </div>

    <!-- 運転速度 -->
    <div class="section">
      <h2>運転速度</h2>
      <div class="options">
        <!-- ここ value と表示が異なる点は据え置き -->
        <label><input type="radio" name="speed" value="10"> 20m/min</label>
        <label><input type="radio" name="speed" value="20"> 25m/min</label>
        <label><input type="radio" name="speed" value="30"> 30m/min</label>
      </div>
    </div>

    <!-- 待機形態 -->
    <div class="section">
      <h2>待機形態</h2>
      <div class="options">
        <label><input type="radio" name="standby" value="stop"> 停止</label>
        <label><input type="radio" name="standby" value="low"> 低速</label>
      </div>
    </div>

    <!-- 照明設定 -->
    <div class="section">
      <h2>照明設定</h2>
      <div class="options">
        <label><input type="radio" name="lighting" value="on"> ON</label>
        <label><input type="radio" name="lighting" value="off"> OFF</label>
        <label><input type="radio" name="lighting" value="linked"> 連動</label>
      </div>
    </div>

    <!-- AAN設定 -->
    <div class="section">
      <h2>AAN設定</h2>
      <div class="options">
        <label><input type="radio" name="aan" value="on"> ON</label>
        <label><input type="radio" name="aan" value="off"> OFF</label>
      </div>
    </div>

    <div class="button-container">
      <button type="button" id="sendBtn">決定（エス1/エス2まとめて送信）</button>
      <button type="button" id="startBtn">起動</button>
    </div>
    <div class="button-container" style="justify-content:center; margin-top:8px;">
      <button id="debugToggleBtn" style="padding:8px 14px; border-radius:6px; background:#444; color:#fff; opacity:0.9;">デバッグ表示</button>
    </div>
  </div>
  <!-- Debug toggle button - show under the main action buttons, centered -->
  

  <script>
    // --- モデル（エス1/エス2を別々に保持。画面切替しても値が戻らない） ---
    const model = {
      es1: { direction: "UP", operation: "auto", speed: "30", standby: "stop", lighting: "linked", aan: "on" },
      es2: { direction: "UP", operation: "auto", speed: "30", standby: "stop", lighting: "linked", aan: "on" }
    };
    let current = "es1"; // "es1" or "es2"

    // --- 近接フラグ（WebSocketで受信： '0,1' のような3バイト） ---
    const near = { es1: false, es2: false }; // false=未接近, true=接近
    let recvCount = 0;

    // --- WebSocket ---
    // NOTE: Create the WebSocket after DOM loads so we can immediately update DOM on messages
    let socket = null; // will be initialized once DOM ready
    function initWebSocket() {
      // Prevent duplicate sockets if one is already connecting/open
      if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
        console.log('WebSocket already open or connecting');
        return;
      }
      const wsUrl = 'ws://' + window.location.hostname + ':81';
      console.log("WebSocket connecting to:", wsUrl);
      try {
        socket = new WebSocket(wsUrl);
      } catch (e) {
        console.log('WebSocket create failed', e);
        const s = document.getElementById('wsStatus'); if (s) s.textContent = 'WebSocket: create failed';
        return;
      }

      socket.addEventListener('open', () => {
        console.log("WebSocket connected");
        const s = document.getElementById('wsStatus'); if (s) s.textContent = 'WebSocket: connected';
      });
      socket.addEventListener('error', (ev) => { console.log('WebSocket error', ev); const s = document.getElementById('wsStatus'); if (s) s.textContent = 'WebSocket: error'; });
      socket.addEventListener('close', (ev) => { console.log('WebSocket closed', ev); const s = document.getElementById('wsStatus'); if (s) s.textContent = 'WebSocket: closed';
        // Try to reconnect after a delay
        setTimeout(() => {
          console.log('Attempting WebSocket reconnect...');
          initWebSocket();
        }, 3000);
      });

      // ★ 近接データ受信（新フォーマットのみを受け付けます）
      // 新仕様: 受信は「エス1(18) + エス2(18) + 近接2(2)」(合計36+2=38フィールド) のCSV
      // 例: arr.length >= 38 であれば、配列[36]=near.es1, [37]=near.es2
      socket.onmessage = (ev) => {
        const txt = String(ev.data || "").trim();
        const arr = txt.split(",");
        recvCount++;
        console.log('WS recv length=', arr.length, ' raw=', txt, ' count=', recvCount);
        const lastRawEl = document.getElementById('lastRaw'); if (lastRawEl) lastRawEl.textContent = '最後のメッセージ: ' + txt.slice(0,200);
        const recvEl = document.getElementById('recvCount'); if (recvEl) recvEl.textContent = 'メッセージ受信: ' + recvCount;
        if (arr.length >= 38) {
          // trim each item to avoid whitespace causing mismatch
          const clean = arr.map(a => String(a || '').trim());
          const prevNear1 = near.es1;
          const prevNear2 = near.es2;
          near.es1 = (clean[36] === "1");
          near.es2 = (clean[37] === "1");
          const nsEl = document.getElementById('nearStatus'); if (nsEl) nsEl.textContent = `近接: es1=${near.es1} es2=${near.es2}`;
          // Log change; update UI only when change occurred for the current page
          console.log('WS: near es1=', near.es1, 'es2=', near.es2, 'raw36=', clean[36], 'raw37=', clean[37], 'prev1=', prevNear1, 'prev2=', prevNear2);
          // Update current status UI
          const currentEl = document.getElementById('currentStatus'); if (currentEl) currentEl.textContent = '現在のページ: ' + current;
          const prevForCurrent = (current === 'es1') ? prevNear1 : prevNear2;
          const newForCurrent  = (current === 'es1') ? near.es1  : near.es2;
          if (prevForCurrent !== newForCurrent) {
            // Add blink effect to button when updated
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
              startBtn.classList.remove('blink');
              void startBtn.offsetWidth; // force reflow
              startBtn.classList.add('blink');
            }
            updateStartButtonAppearance();
            console.log('UI updated due to change for', current, 'from', prevForCurrent, 'to', newForCurrent);
          } else {
            console.log('No UI update required: same near for', current, '(', newForCurrent, ')');
          }
        } else {
          // 新フォーマット以外は無視（旧フォーマットはサポートしない）
          console.warn('WS recv too short, ignoring', arr.length, txt);
          // (If you want to support older formats, add parsing here.)
        }
      };
    }

    // --- 起動ボタンの外観切替（接近中=緑 / 未接近=グレー + 無効化） ---
    function updateStartButtonAppearance() {
      const btn = document.getElementById("startBtn");
      if (!btn) return; // guard if DOM not yet ready
      const isNear = (current === "es1") ? near.es1 : near.es2;

      if (isNear) {
        btn.classList.remove('start-disabled');
        btn.classList.add('start-enabled');
        btn.style.cursor = "pointer";
        btn.disabled = false;
        btn.style.opacity = "1";
      } else {
        btn.classList.remove('start-enabled');
        btn.classList.add('start-disabled');
        btn.style.cursor = "not-allowed";
        btn.disabled = true;                  // ★ 無効化
        btn.style.opacity = "1";
      }
      // Update nearStatus debug text
      const ns = document.getElementById('nearStatus');
      if (ns) ns.textContent = `近接: es1=${near.es1} es2=${near.es2}`;
    }

    // --- ユーティリティ：フォーム→モデル保存 / モデル→フォーム反映 ---
    function saveFromForm() {
      const sel = (name) => {
        const el = document.querySelector(`input[name="${name}"]:checked`);
        return el ? el.value : null;
      };
      const m = model[current];
      m.direction = sel("direction") ?? m.direction;
      m.operation = sel("operation") ?? m.operation;
      m.speed     = sel("speed")     ?? m.speed;
      m.standby   = sel("standby")   ?? m.standby;
      m.lighting  = sel("lighting")  ?? m.lighting;
      m.aan       = sel("aan")       ?? m.aan;
    }

    function applyToForm() {
      const m = model[current];
      const set = (name, value) => {
        const el = document.querySelector(`input[name="${name}"][value="${value}"]`);
        if (el) el.checked = true;
      };
      set("direction", m.direction);
      set("operation", m.operation);
      set("speed",     m.speed);
      set("standby",   m.standby);
      set("lighting",  m.lighting);
      set("aan",       m.aan);
      // タイトル/ヒント/ボタン文言
      document.getElementById("title").textContent = current === "es1" ? "エス1 機能設定" : "エス2 機能設定";
      document.getElementById("whichHint").textContent = `現在: ${current === "es1" ? "エス1" : "エス2"} を編集中（ボタンで切替できます）`;
      document.getElementById("toggleBtn").textContent = current === "es1" ? "エス2 機能設定へ" : "エス1 機能設定へ";
      const currentEl = document.getElementById('currentStatus'); if (currentEl) currentEl.textContent = '現在のページ: ' + current;

      // 画面切替時にもボタン外観を更新
      updateStartButtonAppearance();
    }

    // ラジオ変更で即モデル反映（切替時に漏れなく保持されるように）
    document.addEventListener("change", (e) => {
      if (e.target.matches('input[type="radio"]')) {
        saveFromForm();
      }
    });

    // 切替ボタン
    document.getElementById("toggleBtn").addEventListener("click", () => {
      saveFromForm();
      current = (current === "es1") ? "es2" : "es1";
      applyToForm();
    });

    // 送信用ペイロード生成（startフラグの挙動を切替）
    function buildPayload({ startPressed }) {
      saveFromForm();
      const s1 = model.es1;
      const s2 = model.es2;

      // デフォルトは両方false（決定ボタン時）
      let start  = false;
      let start2 = false;

      // 起動ボタン時は、表示中のエスのみtrue、もう片方はfalse固定
      if (startPressed) {
        if (current === "es1") { start = true;  start2 = false; }
        else                   { start = false; start2 = true;  }
      }

      return {
        // エス1
        direction: s1.direction, operation: s1.operation, speed: s1.speed,
        standby: s1.standby, lighting: s1.lighting, aan: s1.aan,
        // エス2（語尾2）
        direction2: s2.direction, operation2: s2.operation, speed2: s2.speed,
        standby2: s2.standby, lighting2: s2.lighting, aan2: s2.aan,
        // 追加：起動フラグ
        start: start, start2: start2
      };
    }

    // 「決定」：両方 start=false
    document.getElementById("sendBtn").addEventListener("click", () => {
      const payload = buildPayload({ startPressed: false });
      const msg = JSON.stringify(payload);
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        console.warn('WebSocket is not open, cannot send.');
        const s = document.getElementById('wsStatus'); if (s) s.textContent = 'WebSocket: not connected';
        return;
      }
      socket.send(msg);
      console.log("Sent (決定):", msg);
    });

    // 「起動」：表示中のみ true、もう片方 false（未接近なら無効）
    document.getElementById("startBtn").addEventListener("click", () => {
      const btn = document.getElementById("startBtn");
      if (btn.disabled) return; // ★ 無効時は処理しない

      const payload = buildPayload({ startPressed: true });
      const msg = JSON.stringify(payload);
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        console.warn('WebSocket is not open, cannot send.');
        const s = document.getElementById('wsStatus'); if (s) s.textContent = 'WebSocket: not connected';
        return;
      }
      socket.send(msg);
      console.log("Sent (起動):", msg);
    });

    // 初期反映
    window.addEventListener("DOMContentLoaded", () => {
      applyToForm();
      updateStartButtonAppearance(); // 初期は未接近扱い→グレー表示
      // Initialize the websocket after DOM is ready so UI can be updated immediately on messages
      initWebSocket();
      // Hook up debug toggle
      const debugBtn = document.getElementById('debugToggleBtn');
      const debugPanel = document.getElementById('debugPanel');
      if (debugBtn && debugPanel) {
        // Load previous state from localStorage
        const saved = localStorage.getItem('config_debug_visible');
        const visible = (saved === '1');
        debugPanel.classList.toggle('debug-visible', visible);
        debugPanel.classList.toggle('debug-hidden', !visible);
        debugBtn.textContent = visible ? 'デバッグ非表示' : 'デバッグ表示';
        debugBtn.addEventListener('click', () => {
          const nowVisible = debugPanel.classList.toggle('debug-visible');
          debugPanel.classList.toggle('debug-hidden', !nowVisible);
          debugBtn.textContent = nowVisible ? 'デバッグ非表示' : 'デバッグ表示';
          localStorage.setItem('config_debug_visible', nowVisible ? '1' : '0');
        });
      }
    });
  </script>
</body>
</html>
